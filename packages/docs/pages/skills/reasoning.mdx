# Reasoning with multiple commands

Bots can handle complex conversations by managing multiple steps in sequence, maintaining context, and waiting for user responses. This creates a more natural interaction flow.

## How it works

As we seen in previous sections, the bot can handle complex conversations by managing multiple steps in sequence, maintaining context, and waiting for user responses.

1. [Command definition](/skills/commands.mdx): First, we define our bot's available commands.
2. [Natural language](/skills/natural.mdx): Bot interprets user intent and translates it into a sequence of commands.
3. Sequential execution: Commands are executed in logical order.
4. Context maintenance: Bot maintains conversation state.

## Example: Ens domain registration

Let's walk through a complete ENS domain registration flow:

:::steps

### User initiates the conversation

```bash
lets register fabriethsf.eth
```

### Bot skills definition

```typescript
[
  {
    name: "ENS Bot",
    skills: [
      {
        command: "/check [domain]",
        handler: handleEns,
        description: "Check if a domain is available.",
      },
      {
        command: "/register [domain]",
        handler: handleEns,
        description: "Register a domain.",
      },
      {
        command: "/info [domain]",
        handler: handleEns,
        description: "Get information about a domain.",
      },
    ],
  },
];
```

### Handler implementation

```typescript
async function handleEns(context: HandlerContext) {
  const { command, params } = context.message.content;
  const { domain } = params;

  switch (command) {
    case "check":
      const isAvailable = await checkDomain(domain);
      return {
        code: 200,
        message: isAvailable
          ? `Domain ${domain} is available!`
          : `Domain ${domain} is already taken.`,
      };

    case "register":
      const registration = await registerDomain(domain);
      return {
        code: 200,
        message: `https://app.ens.domains/name/${domain}/register`,
      };

    case "info":
      const info = await getDomainInfo(domain);
      return {
        code: 200,
        message: `Domain info: ${JSON.stringify(info)}`,
      };
  }
}
```

### Multiline prompt parsing

The bot processes the natural language input "lets register fabriethsf.eth" and breaks it down into sequential steps:

```typescript
// Bot's internal reasoning process
const steps = [
  {
    thought: "Need to check domain availability first",
    command: "/check fabriethsf.eth",
  },
  {
    thought: "If available, proceed with registration",
    command: "/register fabriethsf.eth",
  },
  {
    thought: "Confirm registration by getting domain info",
    command: "/info fabriethsf.eth",
  },
];

// Execute steps sequentially
for (const step of steps) {
  const response = await context.skill(step.command);
  await context.send(response.message);

  // Wait for user confirmation if needed
  if (step.requiresConfirmation) {
    const confirmation = await context.waitForResponse();
    if (!confirmation.isPositive) break;
  }
}
```

:::

## Best Practices

- Sequential logic: Always follow a logical order of operations
- User confirmation: Get user confirmation before critical actions
- Clear communication: Keep users informed at each step
- Error handling: Gracefully handle failures and provide clear feedback
- Context awareness: Maintain conversation state throughout the interaction

## Advanced Features

- Conditional flows: Different paths based on user responses
- State management: Track conversation progress
- Error recovery: Handle interruptions and resume flows
- Multi-step validation: Validate at each step before proceeding
