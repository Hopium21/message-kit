# Database

In this example we will use Redis DB to manage state.

## Install dependency

Install the redis client in your project.

```bash [cmd]
yarn add @redis/client
```

## Redis middleware

Copy paste the following code in your `lib/redis.ts` file.

```jsx [src/lib/redis.ts]
import { createClient } from "@redis/client";

export const getRedisClient = async () => {
  const client = createClient({
    url: process.env.REDIS_CONNECTION_STRING,
  });
  await client.connect();
  return client;
};

/* To boost the efficiency of managing XMTP conversations, a caching mechanism is essential. Utilizing fs-persistence or Redis allows the system to swiftly verify the existence of a conversation, eliminating the need to reload and inspect every conversation.
This method greatly accelerates both initial and subsequent requests, minimizing wait times and preventing timeouts.
For additional information on configuring fs-persistence with XMTP, please consult the fs-persistence documentation.
The need for this caching mechanism stems from the requirement to ascertain whether newConversation is continuing an existing conversation or starting a new one. This verification aids in avoiding duplicate conversations with the same user, ensuring compliance with privacy standards. */
export const getRedisConfig = async (redisClient: any) => {
  const redisPersistence = await import("@xmtp/redis-persistence");
  const appConfig = {
    basePersistance: new redisPersistence.RedisPersistence(
      redisClient as any,
      "xmtp:"
    ),
  };
  return appConfig;
};
```

## Add Redis

Import the redis config file and send it as parameter to the `run` function.

```jsx [src/index.ts]
import "dotenv/config";
import { getRedisClient, getRedisConfig } from "./lib/redis.js";
import cron from "node-cron";
import { ContentTypeText } from "@xmtp/content-type-text";
import { xmtpClient, run, HandlerContext } from "message-kit";

//Tracks conversation steps
const inMemoryCacheStep = new Map<string, number>();

//List of words to stop or unsubscribe.
const stopWords = ["stop", "unsubscribe", "cancel", "list"];
async function start() {
  const redisClient = await getRedisClient();

  const appConfig = {
    client: await getRedisConfig(redisClient), // Send it at the apptm of the run function
  };

  run(
    async (context: HandlerContext) => {
      const {
        message: {
          content: { content: text },
          typeId,
          sender: { address: senderAddress },
        },
      } = context;

      if (typeId !== "text") {
        /* If the input is not text do nothing */
        return;
      }

      const lowerContent = text?.toLowerCase();

      //Handles unsubscribe and resets step
      if (stopWords.some((word) => lowerContent.includes(word))) {
        inMemoryCacheStep.set(senderAddress, 0);
        await redisClient.del(senderAddress);
        await context.reply(
          "You are now unsubscribed. You will no longer receive updates!.",
        );
      }

      const cacheStep = inMemoryCacheStep.get(senderAddress) || 0;
      let message = "";
      if (cacheStep === 0) {
        message = "Welcome! Choose an option:\n1. Info\n2. Subscribe";
        // Move to the next step
        inMemoryCacheStep.set(senderAddress, cacheStep + 1);
      } else if (cacheStep === 1) {
        if (text === "1") {
          message = "Here is the info.";
        } else if (text === "2") {
          await redisClient.set(senderAddress, "subscribed"); //test
          message =
            "You are now subscribed. You will receive updates.\n\ntype 'stop' to unsubscribe";
          //reset the app to the initial step
          inMemoryCacheStep.set(senderAddress, 0);
        } else {
          message =
            "Invalid option. Please choose 1 for Info or 2 to Subscribe.";
          // Keep the same step to allow for re-entry
        }
      } else {
        message = "Invalid option. Please start again.";
        inMemoryCacheStep.set(senderAddress, 0);
      }

      //Send the message
      await context.reply(message);
    }, //@ts-ignore
    appConfig,
  );

}

start();
```
