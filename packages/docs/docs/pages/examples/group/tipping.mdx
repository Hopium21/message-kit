# Tipping

In this example you can tip using 3 primitives:

- Emoji reaction `emoji:ðŸŽ©`
- Text message starting with `/tip @bob 10 degen`
- Reply `10 $degen`

## Commands

```bash [cmd]
/tip @bob @alice 15
```

::::note[Commands]
To declare this commands you need to add them first. Learn more about commands [here](/concepts/commands).
:::details[Snippet]

```json
{
  "name": "Tipping",
  "icon": "ðŸŽ©",
  "description": "Tip tokens via emoji, replies or command.",
  "commands": [
    {
      "command": "/tip [@users] [amount] [token]",
      "description": "Tip users in a specified token.",
      "params": {
        "username": {
          "default": "",
          "type": "username"
        },
        "amount": {
          "default": 10,
          "type": "number"
        }
      }
    }
  ]
}
```

:::
::::

## Logic

```jsx [src/handler/tipping.ts]
import { HandlerContext } from "@xmtp/mkit";
import { users } from "../lib/users.js";

export async function handler(context: HandlerContext) {
  const { senderAddress, content, typeId } = context.message;
  const { params } = content;
  let amount: number = 0,
    receiverAddresses: string[] = [],
    reference: string = "";

  // Handle different types of messages
  if (typeId === "reply") {
    const { content: reply, receiver } = content;
    // Process reply messages
    receiverAddresses = [receiver];
    if (reply.includes("$degen")) { //  [!code hl] // [!code focus]
      const match = reply.match(/(\d+)/);
      if (match) amount = parseInt(match[0]); // Extract amount from reply
    }
  } else if (typeId === "text") {
    const { content: text } = content;
    // Process text commands starting with "/tip"
    if (text.startsWith("/tip")) { //  [!code hl] // [!code focus]
      const { amount: extractedAmount, username } = params;

      amount = extractedAmount || 10; // Default amount if not specified
      receiverAddresses = username; // Extract receiver from parameters
    }
  } else if (typeId === "reaction") {
    const { content: reaction, action, receiver } = content;

    // Process reactions, specifically tipping added reactions
    if (reaction === "ðŸŽ©" && action === "added") { //  [!code hl] // [!code focus]
      amount = 10; // Set a fixed amount for reactions
      receiverAddresses = [receiver];
    }
  }
  // Find sender user details
  const sender = users.find((user: any) => user.address === senderAddress);

  // Validate transaction feasibility
  if (!sender || receiverAddresses.length === 0 || amount === 0) {
    context.reply("Sender or receiver or amount not found.");
    return;
  }

  // Check if sender has enough tokens
  if (sender.tokens >= amount * receiverAddresses.length) {
    // Process sending tokens to each receiver
    receiverAddresses.forEach(async (receiver: any) => {
      context.reply(
        `You received ${amount} tokens from ${sender.username}. Your new balance is ${receiver.tokens} tokens.`,
        [receiver.address], // Notify only 1 address //  [!code hl] // [!code focus]
      );
    });
    // Notify sender of the transaction details
    context.reply(
      `You sent ${
        amount * receiverAddresses.length
      } tokens in total. Your remaining balance: ${
        sender.tokens // The hypotetical logic of distributing tokens //  [!code hl] // [!code focus]
      } tokens.`,
      [sender.address], // Notify only 1 address //  [!code hl] // [!code focus]
      reference,
    );
  } else {
    context.reply("Insufficient tokens to send.");
  }
}
```
