# Redis

Integrate Redis with your bot to manage state.

### Install dependency

```bash
yarn add @redis/client
```

### Create a Redis client

Import the redis config file and send it as parameter to the `run` function.

```jsx [index.ts]
async function start() {
  const redisClient = await getRedisClient();
  const newBotConfig = await getRedisConfig(redisClient);
  run(async (context: HandlerContext) => {
    const { content, senderAddress } = context.message;

    const existingSubscription = await redisClient.get(senderAddress);

    //Manage user subscription
    if(/*user unsubscribed*/){
      await redisClient.del(senderAddress);
      await context.reply("You have been unsubscribed.");
      return;
    }else if (/*user subscribed*/){
      await redisClient.set(senderAddress, "subscribed");
      await context.reply("Thanks for subscribing. You'll receive daily updates.");
      return;
    } else if (existingSubscription) {
      await context.reply("You are already subscribed.");
      return;
    }

  }, newBotConfig);

  // Run the cron job every day
  cron.schedule(
    "0 18 * * *",
    () => fetchFromDBandSend(), //Send daily a message to subscribers
    {
      runOnInit: false,
      timezone: "Europe/Rome",
    }
  );
}

start();
```

```jsx [lib/redis.ts]
import { createClient } from "@redis/client";

export const getRedisClient = async () => {
  const client = createClient({
    url: process.env.REDIS_CONNECTION_STRING,
  });
  await client.connect();
  return client;
};

/* To boost the efficiency of managing XMTP conversations, a caching mechanism is essential. Utilizing fs-persistence or Redis allows the system to swiftly verify the existence of a conversation, eliminating the need to reload and inspect every conversation.
This method greatly accelerates both initial and subsequent requests, minimizing wait times and preventing timeouts.
For additional information on configuring fs-persistence with XMTP, please consult the fs-persistence documentation.
The need for this caching mechanism stems from the requirement to ascertain whether newConversation is continuing an existing conversation or starting a new one. This verification aids in avoiding duplicate conversations with the same user, ensuring compliance with privacy standards. */
export const getRedisConfig = async (redisClient: any) => {
  const redisPersistence = await import("@xmtp/redis-persistence");
  const newBotConfig = {
    basePersistance: new redisPersistence.RedisPersistence(
      redisClient as any,
      "xmtp:"
    ),
  };
  return newBotConfig;
};
```
