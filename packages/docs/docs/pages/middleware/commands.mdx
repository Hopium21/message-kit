# Commands

### Example Usage

`commandConfig` is an object where each key is a command and each value is an object describing the parameters and their options if necessary.

```typescript
const commandConfig = {
  send: {
    params: {
      amount: [],
      token: ["eth", "dai", "usdc", "degen"],
      username: [],
    },
  },
  swap: {
    params: {
      amount: [],
      token_from: ["eth", "dai", "usdc", "degen"],
      token_to: ["eth", "dai", "usdc", "degen"],
    },
  },
  // Additional commands...
};
```

Letâ€™s see how you might use these in a simple example:

```typescript
const input = "/send 100 eth @bob";
const parsedCommand = extractCommandValues(input, commandConfig);
```

Result:

```json
{
  "command": "send",
  "params": { "amount": "100", "token": "eth", "username": "@bob" }
}
```

Use this script to manage commands.

### Add `helper.ts` file

Copy paste the `helper.ts` file into your project.

```jsx [lib/helper.ts]
interface CommandConfig {
  [command: string]: {
    params: { [param: string]: string[] }; // Possible values for each parameter
  };
}
interface ExtractedValues {
  command: string | undefined;
  params: { [key: string]: string | string[] | undefined };
}

export function extractCommandValues(
  content: string,
  commandConfig: CommandConfig,
): ExtractedValues {
  const parts = content.split(" ");
  let command = parts.find((part) =>
    Object.keys(commandConfig).includes(part.toLowerCase().replace(/^\//, "")),
  );
  if (command?.startsWith("/")) command = command.slice(1);

  if (!command) {
    console.log("No valid command found in the input.");
    return { command: undefined, params: {} };
  }

  const values: ExtractedValues = {
    command: command,
    params: {},
  };

  const expectedParams = commandConfig[command.toLowerCase()].params;
  const usedIndices: Set<number> = new Set();

  Object.keys(expectedParams).forEach((param) => {
    const possibleValues = expectedParams[param];
    if (possibleValues.length > 0) {
      const index = parts.findIndex(
        (part, idx) =>
          possibleValues.includes(part.toLowerCase()) && !usedIndices.has(idx),
      );
      if (index !== -1) {
        values.params[param] = parts[index];
        usedIndices.add(index);
      } else {
        // If no value is found and there is a default value, assign it
        if (expectedParams[param].length === 1) {
          values.params[param] = expectedParams[param][0];
        } else {
          console.error(`Expected parameter '${param}' not found.`);
        }
      }
    } else {
      // Handle numeric and other types of parameters
      switch (param) {
        case "amount":
          const numericIndex = parts.findIndex(
            (part, idx) => !isNaN(parseFloat(part)) && !usedIndices.has(idx),
          );
          if (numericIndex !== -1) {
            values.params[param] = parts[numericIndex];
            usedIndices.add(numericIndex);
          } else {
            console.error(`Expected numeric parameter '${param}' not found.`);
          }
          break;
        case "username":
          const usernames = parts.filter(
            (part, idx) => part.startsWith("@") && !usedIndices.has(idx),
          );
          if (usernames.length > 0) {
            values.params[param] = usernames;
            usernames.forEach((_, idx) => usedIndices.add(idx));
          } else {
            console.error(`Expected username parameter '${param}' not found.`);
          }
          break;
        case "address":
          const addressIndex = parts.findIndex(
            (part, idx) => part.startsWith("0x") && !usedIndices.has(idx),
          );
          if (addressIndex !== -1) {
            values.params[param] = parts[addressIndex];
            usedIndices.add(addressIndex);
          } else {
            console.error(`Expected address parameter '${param}' not found.`);
          }
          break;
        default:
          console.error(`Unhandled parameter type '${param}'.`);
          break;
      }
    }
  });

  return values;
}
```
